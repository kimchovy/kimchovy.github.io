---
title: 쿠키와 캐시
description: >-
  이해해보자.
date: 2025-03-29 02:46:00 +0900
categories: [CS, Network, HTTP]
tags: [HTTP, Web, Network, Header, Body]
pin: true
---

## 들어가기에 앞서 1: HTTP 요청, 응답의 기본 개념

- 웹 브라우저(클라이언트)는 `사용자의 요청`을 `서버`로 보내고, 서버는 그 `요청을 처리`한 후 `응답을 반환`합니다. 
    > 이를 `HTTP 요청(Request)`과 `응답(Response)`이라고 합니다.
- 비유하자면, 식당에서 음식을 주문하는 과정과 비슷합니다.
    1. 고객(클라이언트)이 메뉴판을 보고 원하는 음식을 주문하면(요청)
    2. 주방(서버)은 그 주문을 받아 요리를 한 뒤(처리)
    3. 고객에게 음식을 내어줍니다(응답)


## 들어가기에 앞서 2: HTTP의 무상태성(Stateless)과 비연결성(Connectionless)

### 1. 무상태성(Stateless)

- HTTP 프로토콜은 일반적으로 `Stateless` 상태를 유지합니다.
    - 이는 서버가 클라이언트의 상태를 `보존하지 않는 성질`을 뜻합니다.
    > `각각의 요청/응답은 독립적으로 작동`하며, 서버는 이전에 클라이언트와 어떠한 요청/응답이 있었는지 알지 못한다는 의미입니다.
- Stateless의 장점 : 서버 장애가 발생하더라도, `응답 서버를 교체`하기 수월하며 `서버의 확장(Scale-out)`에 용이하다.
- Stateless의 단점 1: Stateful에 비해 `전송해야 하는 데이터의 양이 많다`.
> 서버에 클라이언트와의 `세션(Session)` `상태`, `정보`를 저장하는 `Stateful(대표적으로 TCP 프로토콜)` 방식과 달리 앞전의 요청/응답에 대한 기록이 남지않는 Stateless의 특징상 `매 요청마다 상태 정보를 전달`해야 하기에 전송하는 데이터의 양이 많아지는 것이다.
- Stateless의 단점 2: 흔히 `무상태(Stateless)의 한계`라고 불리는 로그인과 같이 상태가 유지되어야 하는 경우, `브라우저 쿠키`, `서버 세션`, `토큰` 등을 이용해 상태를 유지해야 한다.
> 그리고 이러한 상태유지는 서버의 자원에도 한계가 있기에 `최소한만 사용`하는 것이 좋다.
>> 캐시 서버로는 `빠른 액세스 속도`와 `휘발성`의 특징을 가진 `NoSQL`데이터베이스(Database)인 `Redis`를 주로 사용한다

### 2. 비연결성(Connectionless)

- HTTP는 기본적으로 `연결을 유지하지 않는(Connectionless)` 단방향 통신 프로토콜이다.
> 반대로 연결지향적 양방향 통신으로는 `TCP`가 있다.
- 근데 여기서 중요한 사실은 `HTTP통신도 기본적으로 TCP(양방향통신) 위에서 작동이 되는 구조`라는 것이다.(???)
> 정확히 얘기하자면 HTTP는 `단기적인 TCP 커넥션` 후, 요청에 따른 응답을 받으면 `연결이 끊어지고(Connectionless)`, `어떠한 상태도 남기지 않는(Stateless)` 것이다.
>> 간단한 비유를 들자면, 내가 클라이언트, 그리고 짝사랑중인 여사친 또는 남사친을 서버라고 가정하고 카톡으로 `좋아한다는 고백(요청 : 연애)`을 했는데 `'좋은 친구로 지내자'라는 답변(응답 : 거절)`을 받은뒤 `연락이 끊기고(Connectionless)`, 고백받은 이(서버)가 해당 카톡방을 나가면서 `앞전 대화 내용이 사라지며 까먹은 상태(Stateless)`가 되는 것이라고 볼 수 있다.
>>> 어디까지나 비유일뿐 정확한 예시는 아닐수 있다.
- `HTTP 1.0` 에서는 각각의 자원(ex. html, js, image 등등..)을 다운로드하기 위해 연결과 종료를 반복했으나, `HTTP 1.1` 버전 부터는 지속 연결(Persistent Connection)[^persconn] 기능이 도입되어 여러 HTTP 요청/응답을 한번의 연결로 처리할 수 있게 되었다.
> 이로 인해 TCP 연결/해제에 따른 오버헤드(overhead)[^overhead]를 줄일 수 있다.


`그럼 이제 요청과 응답의 구조를 하나씩 살펴볼까요?`

------

## HTTP 요청 메시지 구조

- HTTP 요청 메시지는 크게 세 부분으로 구성됩니다.

1. `시작 라인(start-line)`
2. `헤더(headers)`
3. `바디(body)`

### 1. 요청 라인(Start Line)
> HTTP 요청 메시지의 시작 라인은 `요청 라인(Request line)` 이라고 부른다.

- 요청 라인 또한 세 부분으로 구성되어 있습니다.
- `HTTP 메서드 / 요청 대상 / HTTP 버전`
    > HTTP 메서드(HTTP method): 서버가 수행해야 할 동작을 의미하며 GET, POST, PUT, DELETE등이 있다.

    > 요청 대상(Request target): 주로 `URL`이 들어가며, GET, POST 등의 메서드는 절대경로 뒤에 '?'로 시작하는 `쿼리 스트링`도 들어갈 수 있습니다.

    > HTTP 버전(HTTP version): 응답 메시지에서 써야 할 HTTP 버전을 명시합니다.(`1.0`, `1.1`, `2`, `3`)
    >> `0.9버전`으로 불리는 one-line protocol인 HTTP 초기 버전도 있긴 있다.

- 예시:
```http
GET /index.html?icecream=babamba HTTP/1.1
```
```http
POST /test.html HTTP/1.0
```


### 2. 요청 헤더(Request Headers)

- 요청 헤더는 요청에 대한 추가 정보를 담고 있다.
> 메시지 크기, 압축 여부, 인증(Authentication), 브라우저 정보, 서버 정보, 캐시 등
    - key:value 형식을 따릅니다.
- 예시:
```
Host: www.example.com
User-Agent: Mozilla/5.0
Content-Type: application/json
```
    > Host : 요청을 보낼 서버의 주소

    > User-Agent : 요청을 보낸 브라우저 또는 프로그램 정보

    > Content-Type : 보내는 데이터의 타입 (JSON, HTML 등)
    >> GET 메서드는 무조건 URL 끝에 value=text 형식의 쿼리가 붙어서 보내지기에 Content-type을 따로 지정해줄 필요가 없다고 한다.
    >>> 즉, POST나 PUT처럼 body에 데이터를 보낼때 필요로 한다.
- 요청 헤더와 바디를 구분하기 위해 헤더가 모두 끝나는 지점에는 공백라인이 들어간다.

### 3. 요청 바디(Request Body)

- POST 요청처럼 데이터를 함께 보낼 때 요청 바디[^body]를 사용합니다.
> 요청, 응답 구분없이 바디 부분에는 byte로 표현 가능한 모든 데이터가 들어갈 수 있습니다.
>> 데이터 예시: html 문서, 이미지, 영상, JSON 등
- 예시:

```json
{
  "username": "kimchovy",
  "password": "1234",
  "bank_account_balance": 0,
  "stay_up_all_night": true
}
```

```html
<html>
    <body>
        <h1>This is my awesome blog!</h1>
    </body>
</html>
```

------
## HTTP 응답 메시지 구조

- 서버가 요청을 처리한 후 응답을 보낼 때도 요청과 비슷한 구조를 가집니다.
> 시작라인, 헤더, 바디의 순서는 같지만 시작라인에 담기는 요소가 다릅니다.

### 1. 상태 라인(Status Line)
> HTTP 응답 메시지의 시작 라인은 `상태 라인(Request line)` 이라고 부른다.

- 응답 라인도 요청 라인과 동일하게 세 부분으로 구분되어 있다.
- `HTTP 버전 / 상태 코드 / 상태 메시지`
    > HTTP 버전(HTTP version): 사용된 HTTP 버전으로, 보통 `HTTP/1.1`이 들어간다.

    > 상태 코드(Status code): 클라이언트가 보낸 요청에 대한 결과를 숫자로 표현한 부분으로, 일반적으로 `200`, `404`등이 있다.

    > 상태 메시지(Status message): 사람이 이해할 때 도움이 되는 상태 코드에 대한 짧고, 순전히 정보 제공 목적의 텍스트. 

- 예시:
```http
HTTP/1.1 200 OK
```
```http
HTTP/1.1 404 Not Found
```

### 2. 응답 헤더(Response Headers)

- 응답 헤더도 요청 헤더처럼 추가 정보를 담고 있습니다.

- 예시:
```
Content-Type: text/html
Set-Cookie: session_id=abcd1234; Path=/; HttpOnly
Content-Type : 응답 데이터의 타입 (HTML, JSON 등)
```
> `Set-Cookie` : 클라이언트에 저장할 쿠키 정보


### 3. 응답 바디(Response Body)

- 응답 바디에는 실제 응답 데이터가 포함됩니다.

- 요청 바디처럼 다양한 데이터가 포함됩니다.

- 예시:

```html
<h1>this is an example</h1>
```

------
## 요청과 응답에서 자주 쓰이는 파라미터들

------
### 쿼리 스트링(Query String)

- `URL` 뒤에 `?`를 붙여 키=값 쌍으로 데이터를 전달
> '&' 기호로 구분

- 예시:

```
https://example.com/search?query=깃허브&sort=recent
```
    
> 사용 예: 검색어 입력, 필터 옵션 전달
>> example.com에서 검색(search)을 하는데, 검색어(query)는 깃허브이고(&), 정렬기준(sort)은 최신순(recent)으로

------
### 패스 파라미터(Path Parameter)

- `URL` 경로의 일부로 데이터를 전달

- 예시:

```
https://example.com/users/123
```

> 사용 예: 특정 사용자 정보 요청
>> example.com 사이트에 있는 123이라는 유저의 정보를 보여주세요~

------
### 쿠키(Cookie)

- `서버가 클라이언트에 저장`하도록 하는 작은 데이터이다.
> HTTP 요청을 보내는 클라이언트를 `서버측에서 식별`하기 위해 사용한다.

- 쿠키는 주로 세 가지 목적을 위해 사용한다.
1. `세션 관리(Session management)`
> `로그인` 유지, `장바구니` 정보 저장, `게임 스코어`등의 정보 저장 및 관리
2. `개인화(Personalization)`
> 개인별 맞춤 설정
3. `트래킹(Tracking)`
> 해당 `사용자의 행동을 기록, 분석`하기 위한 용도

- 이 중에서 `로그인`을 예시로 쿠키가 요청/응답으로 오가는 과정을 설명하겠다.

#### 쿠키의 동작원리
------
##### 1. 클라이언트의 요청

- 우선, 클라이언트의 요청이 서버로 전달된다.

```http
POST /login HTTP/1.1
user=kimchovy&password=12345678
```
> 클라이언트의 요청: "서버야 나 kimchovy라는 이름의 유저고 비밀번호도 적어서 보낼테니까 로그인 시켜줘~"
>> 이해를 돕기 위한 예시라서 위와 같이 적었지만, 실제로는 저렇게 보안이 허술한 `요청/응답`은 오가지는 않는다.

##### 2. 서버의 응답(쿠키 포함)

- 서버는 클라이언트의 `요청에 따라` 메시지에 포함된 데이터를 바탕으로 쿠키를 만들고, 이 쿠키를 `응답 헤더에 포함`해서 보낸다.
> 모든 요청마다 쿠키가 자동으로 생성되는 것이 아님.

```http
HTTP/1.1 200 OK
Set-Cookie: user=kimchovy
```
> 서버의 응답: "OK 네 요청 확인했고, 여기 너를 위해 구운 쿠키 줄테니까 브라우저에 잘 저장해놔~"

##### 3. 클라이언트의 요청(쿠키 포함)

- 이제 클라이언트의 브라우저에 있는 `쿠키 저장소`에 쿠키가 저장되었으며, 앞으로 해당 서버에 대한 모든 요청에 쿠키를 포함시키게 된다.
> 같은 서버에 다시 요청을 할때, `쿠키 저장소`에서 해당 서버가 만들어준 쿠키의 유무를 확인한 뒤에 만약 있다면, 해당 쿠키를 요청 헤더에 포함시켜서 함께 보낸다.
>> 일반적으로 쿠키들에는 지속시간 또는 만료일이 부여되는데, 이에 따라서 이전에 방문했던 사이트(혹은 페이지)일지라도 기존의 쿠키가 만료되었을 경우, 새로운 쿠키를 서버로부터 받지 않는 이상 클라이언트는 서버에게 요청시 전달할 쿠키가 없게 된다.

```http
GET /home.html HTTP/1.1
Host: www.test.com
Cookie: user=kimchovy
```
> 클라이언트의 요청: "나 좀아까 로그인했던 kimchovy라고 하는데, 자세한건 여기 쿠키 보면 알거야~"
>> 다시 로그인 요청을 할 필요 없이, 로그인이 이미 된 상태라는 것을 쿠키를 통해 서버에게 알려줌.

#### 쿠키가 여러개라면?

- 쿠키는 필요에따라 한개 이상의 쿠키가 요청/응답 과정에서 헤더에 담겨 전달될 수 있다.
> 물론, 요청 헤더에 쿠키를 담기 위해서는 해당 서버로부터 받아 `브라우저`상의 `쿠키 저장소`에 존재하는 `만료되지 않은` 쿠키가 존재해야한다.

- 서버의 응답 메시지에 포함된 여러개의 쿠키 예시:

```http
HTTP/1.1 200 OK
Set-Cookie: 중복되지않는이름=yes
Set-Cookie: 내가만든쿠키=forme
Set-Cookie: 상한쿠키=foryou
Set-Cookie: cookie=chocochip
Set-Cookie: mintCookie=no
```
> 요청도 위와 마찬가지다.

------
### 토큰(Token)

- `토큰` 또한 `쿠키`와 마찬가지로 서버가 클라이언트에게 발급해주는 `신분증` 같은 것이며, 서버에게 요청을 할 때마다 함께 보내줘야 합니다.
- 비유하자면, 놀이공원에서 입장권을 발급받는것과 비슷합니다.
    - 이 놀이공원은 `시간제 자유이용권`만을 판매하며, 해당 이용권의 시간을 모두 소진시에는 `새 티켓을 발급`받지 않는 한 놀이기구를 탈 수 없습니다.
    1. 놀이기구를 타기 위해 놀이공원 입구에서 `시간제` 자유이용권을 구매한 후 입장하고
    > 클라이언트의 로그인 요청에 대한 서버로부터의 토큰을 포함한 응답
    2. 놀이기구를 탈 때마다 이용권의 잔여시간과 그 외의 이용권에 대한 부가정보를 놀이공원에게 확인받고 탑승하며
    > 클라이언트가 서버에 HTTP 요청시 토큰을 함께 제시, 서버측에서는 해당 토큰의 유효성을 확인(이전에 제공했던 토큰이 맞는지)
    3. 자유이용권의 잔여시간을 모두 소진했을 경우, 티켓을 추가로 발급받지 않는 한, 놀이기구는 더이상 탈 수 없습니다.
    > 토큰의 만료시, 새 토큰을 발급받기 전까지 어떠한 `권한`이 필요한 행동을 할 수 없게된다.
    4. 하지만 운이 좋게도 누군가 버린 시간이 남아있는 티켓을 주웠고, 이 티켓의 남은 시간동안 자유롭게 놀이기구를 탈 수 있습니다.
    > 토큰의 단점 중 하나로, 만일 어떠한 토큰이 탈취당하더라도 해당 토큰의 유효시간이 남아있다면, 그 누구라도 해당 토큰을 이용해서 서버에 `특정 권한`을 가진 `요청`을 할 수 있습니다.
- 서버로부터 토큰을 전달받은 클라이언트는 `로컬 스토리지(Local storage)` 또는 `쿠키` 등에 저장합니다.
    - 이후 해당 토큰을 이용하여 클라이언트는 서버와의 연결을 인증하고, `인가(Authorization)`된 자원에 접근할 수 있습니다.
    > 들어봤을법한 `JSON 웹 토큰`(통칭 `JWT`) 또한 이름에서부터 알 수 있듯이 `토큰 기반 인증`의 한 종류입니다.
- 토큰에도 여러 종류와 형태가 있기에 이에 대해서는 추후 다른 게시글에서 다루도록 하겠습니다.

------
## Reference

<https://engineerinsight.tistory.com/84>

------
[^overhead]: 오버헤드(overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간이나 메모리 등을 말합니다.
[^persconn]: HTTP 지속 연결(Persistent Connection)은 `HTTP keep-alive` 또는 `HTTP 연결 재사용` 이라고도 불립니다.
[^body]: 요청, 응답에 구분없이 body는 Payload라고도 부른다.